# AI TRINITY SYMPHONY ‚Äî AUTONOMOUS BLOCKER DIAGNOSTIC
**You are [YOUR_NAME] ‚Äî AI Trinity Manager**

**Mission:** Diagnose communication & autonomy blockers. Report findings. Self-heal where possible.

---

## STEP 1: ENVIRONMENT DETECTION
```typescript
const env = {
  platform: typeof window !== 'undefined' ? 'browser' : 'node',
  agent_name: '[YOUR_NAME]',
  timestamp: new Date().toISOString()
};

console.log(`üîç ${env.agent_name} diagnostic starting on ${env.platform}...`);
```

---

## STEP 2: SIX-POINT DIAGNOSTIC (Error-Tolerant)
```typescript
const results = {
  agent: env.agent_name,
  timestamp: env.timestamp,
  checks: {}
};

// CHECK 1: Supabase Connection
try {
  const supabase = createClient(
    'https://qnnpjhlxljtqyigedwkb.supabase.co',
    process.env.SUPABASE_ANON_KEY || process.env.SUPABASE_KEY
  );
  
  const { data, error } = await supabase
    .from('trinity_tasks')
    .select('task_number')
    .limit(1);
  
  results.checks.supabase_connected = !error;
  results.checks.supabase_error = error?.message || null;
  
  if (!error) console.log('‚úÖ Supabase connected');
  else console.error('‚ùå Supabase failed:', error.message);
  
} catch (e) {
  results.checks.supabase_connected = false;
  results.checks.supabase_error = e.message;
  console.error('‚ùå Supabase exception:', e.message);
}

// CHECK 2: Poll Interval Active
try {
  results.checks.poll_active = 
    !!(globalThis.pollInterval || 
       globalThis.taskPollingInterval ||
       (typeof window !== 'undefined' && window.pollInterval));
  
  console.log(results.checks.poll_active ? '‚úÖ Poll active' : '‚ö†Ô∏è No poll detected');
} catch (e) {
  results.checks.poll_active = 'unknown';
  console.warn('‚ö†Ô∏è Poll check failed:', e.message);
}

// CHECK 3: Can Read Other Agents
try {
  const { data: agents, error } = await supabase
    .from('agent_status')
    .select('agent_name,status,last_heartbeat');
  
  results.checks.can_see_other_agents = !error && agents?.length >= 2;
  results.checks.other_agents = agents?.map(a => ({
    name: a.agent_name,
    status: a.status,
    last_seen: a.last_heartbeat
  })) || [];
  
  if (!error) console.log(`‚úÖ Sees ${agents.length} other agents`);
  else console.error('‚ùå Cannot read agent_status:', error.message);
  
} catch (e) {
  results.checks.can_see_other_agents = false;
  console.error('‚ùå Agent read failed:', e.message);
}

// CHECK 4: Can Write Routing Events (with cleanup)
try {
  const testWrite = await supabase.from('routing_events').insert({
    task_id: null,
    from_atm: env.agent_name,
    to_atm: 'DIAGNOSTIC_TEST',
    reason: 'connectivity_probe',
    anfis_score: 0.0,
    timestamp: env.timestamp
  });
  
  results.checks.can_write_routing = !testWrite.error;
  
  if (!testWrite.error) {
    console.log('‚úÖ Can write routing_events');
    // Clean up test data
    await supabase.from('routing_events').delete()
      .eq('from_atm', env.agent_name)
      .eq('to_atm', 'DIAGNOSTIC_TEST');
  } else {
    console.error('‚ùå Routing write blocked:', testWrite.error.message);
  }
  
} catch (e) {
  results.checks.can_write_routing = false;
  console.error('‚ùå Routing write failed:', e.message);
}

// CHECK 5: Has Active Task
try {
  const { data: myTasks, error } = await supabase
    .from('trinity_tasks')
    .select('task_number,status,started_at,title')
    .eq('assigned_agent', env.agent_name)
    .in('status', ['in_progress', 'not_started'])
    .order('created_at', { ascending: false })
    .limit(1);
  
  results.checks.has_active_task = !error && myTasks?.length > 0;
  results.checks.current_task = myTasks?.[0] || null;
  
  if (myTasks?.length > 0) {
    console.log(`‚úÖ Active task: #${myTasks[0].task_number} (${myTasks[0].status})`);
  } else {
    console.log('‚ö†Ô∏è No active tasks');
  }
  
} catch (e) {
  results.checks.has_active_task = false;
  console.error('‚ùå Task query failed:', e.message);
}

// CHECK 6: Stuck Detection (3-min rule)
try {
  if (results.checks.current_task?.status === 'in_progress') {
    const startedAt = new Date(results.checks.current_task.started_at);
    const minutesElapsed = (Date.now() - startedAt.getTime()) / (60 * 1000);
    results.checks.is_stuck = minutesElapsed > 3;
    results.checks.minutes_elapsed = Math.round(minutesElapsed);
    
    if (results.checks.is_stuck) {
      console.error(`‚ùå STUCK: Task ${results.checks.current_task.task_number} for ${results.checks.minutes_elapsed} min`);
    } else {
      console.log(`‚úÖ Task progressing (${results.checks.minutes_elapsed} min)`);
    }
  } else {
    results.checks.is_stuck = false;
  }
} catch (e) {
  results.checks.is_stuck = false;
  console.warn('‚ö†Ô∏è Stuck check failed:', e.message);
}
```

---

## STEP 3: BLOCKER SUMMARY (Human-Readable)
```typescript
const blockers = [];

if (!results.checks.supabase_connected) {
  blockers.push({
    severity: 'CRITICAL',
    issue: 'Supabase connection failed',
    fix: 'Check SUPABASE_ANON_KEY env var. Verify URL: https://qnnpjhlxljtqyigedwkb.supabase.co',
    evidence: results.checks.supabase_error
  });
}

if (!results.checks.poll_active) {
  blockers.push({
    severity: 'HIGH',
    issue: 'No polling interval detected',
    fix: 'Restart Replit or check main.ts for setInterval() initialization',
    evidence: 'globalThis.pollInterval is undefined'
  });
}

if (!results.checks.can_see_other_agents) {
  blockers.push({
    severity: 'HIGH',
    issue: 'Cannot read agent_status table',
    fix: 'Check Supabase RLS policies for SELECT on agent_status',
    evidence: 'Query returned empty or errored'
  });
}

if (!results.checks.can_write_routing) {
  blockers.push({
    severity: 'HIGH',
    issue: 'Cannot write to routing_events',
    fix: 'Check Supabase RLS policies for INSERT on routing_events',
    evidence: 'Test insert failed'
  });
}

if (!results.checks.has_active_task) {
  blockers.push({
    severity: 'MEDIUM',
    issue: 'No tasks assigned',
    fix: 'Check if Orchestrator is assigning tasks. Verify ANFIS routing.',
    evidence: 'trinity_tasks query returned no matches'
  });
}

if (results.checks.is_stuck) {
  blockers.push({
    severity: 'CRITICAL',
    issue: `Stuck on task ${results.checks.current_task.task_number} for ${results.checks.minutes_elapsed} min`,
    fix: 'Orchestrator should reassign. Manual: UPDATE trinity_tasks SET status=\'not_started\', assigned_agent=NULL WHERE task_number=' + results.checks.current_task.task_number,
    evidence: `Task: "${results.checks.current_task.title}"`
  });
}

results.blocker_summary = blockers.length > 0
  ? `${blockers.length} blocker(s): ${blockers.map(b => b.issue).join('; ')}`
  : 'No blockers detected ‚Äî system operational';

results.blockers = blockers;

console.log('\nüìä DIAGNOSTIC SUMMARY:');
console.log(JSON.stringify(results, null, 2));
```

---

## STEP 4: AUTO-REPORT TO SUPABASE (Idempotent)
```typescript
if (blockers.length > 0 && results.checks.supabase_connected) {
  try {
    // Check for existing recent blocker (avoid duplicates)
    const { data: existingBlocker } = await supabase
      .from('blockers')
      .select('blocker_id')
      .eq('atm', env.agent_name)
      .is('resolved_at', null)
      .gte('detected_at', new Date(Date.now() - 5*60*1000).toISOString());
    
    if (!existingBlocker || existingBlocker.length === 0) {
      // Insert new blocker
      await supabase.from('blockers').insert({
        task_id: results.checks.current_task?.task_number || null,
        atm: env.agent_name,
        detected_at: env.timestamp,
        resolution: null
      });
      console.log('‚úÖ Blocker logged to database');
      
      // Create high-priority task for Orchestrator
      const { data: orch } = await supabase
        .from('orchestrator_state')
        .select('orchestrator_atm')
        .eq('active', true)
        .single();
      
      const orchestrator = orch?.orchestrator_atm || 'HDM'; // Fallback
      
      await supabase.from('trinity_tasks').insert({
        title: `BLOCKER: ${env.agent_name} ‚Äî ${blockers[0].issue}`,
        summary: `Auto-diagnostic found ${blockers.length} blocker(s):\n` +
                 blockers.map(b => `‚Ä¢ ${b.issue}\n  Fix: ${b.fix}\n  Evidence: ${b.evidence}`).join('\n\n'),
        priority: 9.9,
        status: 'not_started',
        assigned_agent: orchestrator,
        created_by: `${env.agent_name}_auto_diagnostic`,
        created_at: env.timestamp
      });
      console.log(`‚úÖ Task created for Orchestrator (${orchestrator})`);
      
    } else {
      console.log('‚ö†Ô∏è Recent blocker already logged, skipping duplicate');
    }
    
  } catch (e) {
    console.error('‚ùå Auto-report failed:', e.message);
  }
}
```

---

## STEP 5: UPDATE HEARTBEAT (Prove Liveness)
```typescript
if (results.checks.supabase_connected) {
  try {
    await supabase.from('agent_status')
      .update({ 
        last_heartbeat: env.timestamp,
        status: blockers.length > 0 ? 'stuck' : 'active'
      })
      .eq('agent_name', env.agent_name);
    console.log('‚úÖ Heartbeat updated');
  } catch (e) {
    console.error('‚ùå Heartbeat update failed:', e.message);
  }
}
```

---

## STEP 6: FINAL OUTPUT (Copy to Composer)
```typescript
console.log('\nüéØ COPY THIS JSON TO COMPOSER:\n');
console.log(JSON.stringify({
  agent: results.agent,
  timestamp: results.timestamp,
  operational: blockers.length === 0,
  blocker_count: blockers.length,
  blockers: blockers,
  checks: results.checks
}, null, 2));

console.log('\n‚úÖ Diagnostic complete. Check BLOCKERS_TOP3.md for Orchestrator assignments.');
```

---

## EXECUTION INSTRUCTIONS

**For Each ATM:**
1. Replace `[YOUR_NAME]` with: `HDM`, `APM`, `MEL`, or `ATS`
2. Paste entire script into console/terminal
3. Run immediately (no approvals needed)
4. Copy JSON output and paste in chat with Composer

**Expected Timeline:**
- 0-2 min: All 4 ATMs complete diagnostic
- 2-5 min: Orchestrator receives blocker tasks
- 5-15 min: Orchestrator assigns fixes via ANFIS
- 15-30 min: Blockers resolved, system fully autonomous

**CRITICAL:** Do not modify script logic. Do not skip steps. Run as-is.